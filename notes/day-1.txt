git repo:
https://github.com/joydip-git/siemens-dotnetcore-24thnov2025

.NET/.NET Core

.NET Framework => 4.8 (2019) => legacy

Common Language Run-time (CLR) => mscoree.dll
MS common object runtime execution engine

.NET Framework:
1.0 => 1.0 => 1.0
1.1 => 1.0 => 1.1
2.0 => 2.0 => 2.0
3.0 => 2.0 => 3.0
3.5 => 2.0 => 3.5
4.0 => 4.0 => 4.0
4.5 => 4.0 => 5.0
4.6 => 4.0 => 6.0
4.7 => 4.0 => 7.0
4.8 => 4.0 => 8.0

ILDASM => can dis assemble ONLY the assemblies 


.NET Core => 1.0 (2016) -> 3.1

.NET => 5, 7, 9 (STS)
.NET => 6,8,10 (LTS)

Console => Core runtime (Core CLR)
Desktop => Desktop runtime (Desktop CLR)
web => ASP.NET Core runtime 

.NET SDK includes all the 3 runtimes

compiler for C# and VB => Roslyn

.NET executable applications, when compiled will produce an assembly with .dll extension and also a host of the assembly with .exe extension.
.NET library applications, when compiled will produce just an assembly with .dll extension.

.NET advantages
	=> cross-platform
	=> modular
	=> smaller package size
	=> open source

.NET features
	=> built in container for DI
	=> built in configuration provider
	=> built in logging facility
	=> built in hosting service
		=> application lifetime		
		=> graceful shutdown
		=> all the services 


.NET/.NET Core and C# version history
5.0 => 9.0
6.0 => 10.0
7.0 => 11.0
8.0 => 12.0
9.0 => 13.0
10.0 => 14.0



classes:
	Microsoft.Extensions.*
interfaces
	Microsoft.Extensions.*.Abstractions

class PaymentService:IPaymentService
{
	PayOnDelivery(){}	
}

class OnlinePaymentService:BasicPaymentService
{
	PayViaCreditCard(){}
}
class CreditPaymentService:BasicPaymentService
{
	PayViaCreditCard(){}
}
class OnlinePaymentService:CreditPaymentService
{
	PayViaOnlineBanking{}
}
interface IBuilder{}

class Builder: IBuilder
{
	private readonly PaymentService ps = new PaymentService();
	public IBuilder AddPayOnDelivery()
	{
		//code...
		return this;
	}
	public IBuilder AddPayOnLine(){ return this;}
	public IBuilder AddPayViaCredit(){ return this;}
	public IBuilder AddPayViaUPI(){ return this; }

	public PaymentService BuildPaymentService()
	{
		return ps;
	}
}

IBuilder builder = new Builder();
IPaymentService ps = builder
	.AddPayOnDelivery()
	.AddPayOnLine();
	.BuildPaymentService();


Callback mechanism:
-------------------------
func B(){}
func A(B)
	B()


public delegate bool LogicDel(int number);

public class LogicDel: MulticastDelegate (:Delegate:Object)
{
	MethodInfo _method;
	Object? _target;
	public LogicDel(MethodInfo method, Object? target)
	{
		_method = method;
		_target = target;
	}
	public bool Invoke(int number)
	{
		//code to invoke the method
		if(_target !=null)
			_method.Invoke(_target, new Object[]{number});
		else
			_method.Invoke(null,new Object[]{number}); 
	}
}

delegate bool Predicate(object value);
delegate bool Predicate<in T> (T value);

delegate void Action(object value);
delegate void Action<in T>(T value);

delegate TResult Func<out TResult>();
delegate TResult Func<in T, out TResult>(T value);
delegate TResult Func<in T1, in T2, out TResult>(T1 value1, T2 value2);
......
delegate TResult Func<in T1,.., in T16, out TResult>(T1 value1,..., T16 value16);

delegate void EventHandler(object obj, EventArgs e);

Reflection:
------------------
a. load any assembly dynamically into runtime
b. discover types at runtime from the loaded assembly
c. creating instance dynamically based on the type metadata
d. invoking methods/properties dynamically based on the method/property metadata

TOP => Type Object Pointer
SBI => Sync Block Index


Product
	=> id, name, price, description

ProductEntity 
	=> id, name, price, description,...








	








